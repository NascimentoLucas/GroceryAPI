#nullable enable
using System.Net.Mime;
using GroceryAPI.DTOs;
using GroceryAPI.Models;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Npgsql;

namespace GroceryAPI.Controllers;

[ApiController]
[Route("api/[controller]")]
[Produces(MediaTypeNames.Application.Json)]
public sealed class IngredientsController : ControllerBase
{
    private readonly AppDbContext _db;
    private readonly ILogger<IngredientsController> _logger;

    public IngredientsController(AppDbContext db, ILogger<IngredientsController> logger)
    {
        _db = db;
        _logger = logger;
    }

    // --- Helpers for Postgres error mapping ---
    private static bool IsUniqueViolation(DbUpdateException ex)
        => ex.InnerException is PostgresException pg && pg.SqlState == PostgresErrorCodes.UniqueViolation;

    private static bool IsForeignKeyViolation(DbUpdateException ex)
        => ex.InnerException is PostgresException pg && pg.SqlState == PostgresErrorCodes.ForeignKeyViolation;

    // GET /api/ingredients?query=&page=1&pageSize=20
    [HttpGet]
    [ProducesResponseType(typeof(PagedResult<IngredientDto>), StatusCodes.Status200OK)]
    public async Task<ActionResult<PagedResult<IngredientDto>>> GetAll(
        [FromQuery] string? query,
        [FromQuery] int page = 1,
        [FromQuery] int pageSize = 20,
        CancellationToken ct = default)
    {
        page = page < 1 ? 1 : page;
        pageSize = pageSize is < 1 or > 200 ? 20 : pageSize;

        var q = _db.Ingredients.AsNoTracking();

        // Case-insensitive search; works great with CITEXT, ILIKE is nice for partials
        if (!string.IsNullOrWhiteSpace(query))
        {
            var term = $"%{query.Trim()}%";
            q = q.Where(i => EF.Functions.ILike(i.Name, term));
        }

        var total = await q.CountAsync(ct);

        var items = await q
            .OrderByDescending(i => i.CreatedAt)
            .Skip((page - 1) * pageSize)
            .Take(pageSize)
            .Select(i => new IngredientDto(i.Id, i.Name, i.CreatedAt))
            .ToListAsync(ct);

        return Ok(new PagedResult<IngredientDto>(items, page, pageSize, total));
    }

    // GET /api/ingredients/{id}
    [HttpGet("{id:guid}")]
    [ProducesResponseType(typeof(IngredientDto), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<ActionResult<IngredientDto>> GetById(Guid id, CancellationToken ct = default)
    {
        var i = await _db.Ingredients.AsNoTracking()
            .Where(x => x.Id == id)
            .Select(x => new IngredientDto(x.Id, x.Name, x.CreatedAt))
            .FirstOrDefaultAsync(ct);

        return i is null ? NotFound() : Ok(i);
    }

    // POST /api/ingredients
    [HttpPost]
    [ProducesResponseType(typeof(IngredientDto), StatusCodes.Status201Created)]
    [ProducesResponseType(StatusCodes.Status409Conflict)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    public async Task<ActionResult<IngredientDto>> Create([FromBody] CreateIngredientDto body, CancellationToken ct = default)
    {
        if (!ModelState.IsValid) return ValidationProblem(ModelState);

        var entity = new Ingredient
        {
            // Id and CreatedAt are DB-generated by defaults
            Name = body.Name.Trim()
        };

        _db.Ingredients.Add(entity);

        try
        {
            await _db.SaveChangesAsync(ct);
        }
        catch (DbUpdateException ex) when (IsUniqueViolation(ex))
        {
            return Conflict(new { message = "Ingredient name must be unique." });
        }

        var dto = new IngredientDto(entity.Id, entity.Name, entity.CreatedAt);
        return CreatedAtAction(nameof(GetById), new { id = entity.Id }, dto);
    }

    // PUT /api/ingredients/{id}
    [HttpPut("{id:guid}")]
    [ProducesResponseType(typeof(IngredientDto), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    [ProducesResponseType(StatusCodes.Status409Conflict)]
    public async Task<ActionResult<IngredientDto>> Update(Guid id, [FromBody] UpdateIngredientDto body, CancellationToken ct = default)
    {
        if (!ModelState.IsValid) return ValidationProblem(ModelState);

        var entity = await _db.Ingredients.FirstOrDefaultAsync(x => x.Id == id, ct);
        if (entity is null) return NotFound();

        entity.Name = body.Name.Trim();

        try
        {
            await _db.SaveChangesAsync(ct);
        }
        catch (DbUpdateException ex) when (IsUniqueViolation(ex))
        {
            return Conflict(new { message = "Ingredient name must be unique." });
        }

        var dto = new IngredientDto(entity.Id, entity.Name, entity.CreatedAt);
        return Ok(dto);
    }

    // DELETE /api/ingredients/{id}
    [HttpDelete("{id:guid}")]
    [ProducesResponseType(StatusCodes.Status204NoContent)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    [ProducesResponseType(StatusCodes.Status409Conflict)]
    public async Task<IActionResult> Delete(Guid id, CancellationToken ct = default)
    {
        var entity = await _db.Ingredients.FirstOrDefaultAsync(x => x.Id == id, ct);
        if (entity is null) return NotFound();

        _db.Ingredients.Remove(entity);

        try
        {
            await _db.SaveChangesAsync(ct);
        }
        catch (DbUpdateException ex) when (IsForeignKeyViolation(ex))
        {
            // ON DELETE RESTRICT: there are FoodIngredients referencing this Ingredient
            return Conflict(new { message = "Cannot delete: ingredient is referenced by foods." });
        }

        return NoContent();
    }
}
